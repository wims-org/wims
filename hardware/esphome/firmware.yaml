substitutions:
  reader_id: !secret reader_id
  name: rfid-reader-${reader_id}
  friendly_name: RFID Reader ${reader_id}
  wims_url: !secret wims_url

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.4.0
  name_add_mac_suffix: false
  project:
    name: esphome.web
    version: dev
  on_boot:
  # Beep during boot
    - priority: -100.0
      then:
        - rtttl.play: "scanner_beep:d=16,o=5,b=100:4e,4e,4e,8c,p,g,4e" # Star Wars Theme
        - display.page.show: page_qrcode
  

esp32:
  board: esp32-c3-devkitm-1
  variant: esp32c3
  framework:
    #type: esp-idf
    type: arduino

# Enable logging
logger:
  #level: INFO

# Enable Home Assistant API
# api:

# Allow Over-The-Air updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  #power_save_mode: none
  fast_connect: true
  output_power: 8.5

  # Fallback access point
  ap:
    ssid: "${name}"
    password: !secret fallback_psk

# In combination with the `ap` this allows the user
# to provision wifi credentials to the device via WiFi AP.
captive_portal:

# HTTP module
http_request:
  verify_ssl: false

# I2C fÃ¼r RFID (PN532) und OLED-Display
i2c:
  sda: 4
  scl: 5
  scan: true
  id: bus_a

globals:
  - id: device_name
    type: std::string
    restore_value: no
    initial_value: '"${name}"'

  - id: rfid_message
    type: std::string
    restore_value: no
    initial_value: '"Reader init..."'

  - id: scanned_item_name
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: scanned_item_location
    type: std::string
    restore_value: no
    initial_value: '""'

qr_code:
  - id: inventory_manager_url_qr
    value: "${wims_url}?reader_id=${reader_id}"

# RFID-Modul PN532
pn532_i2c:
  update_interval: 1s
  on_tag:
    then:
      - display.page.show: page_info
      - lambda: |-
          id(rfid_message) = "Loading...";
      - rtttl.play: "scanner_beep:d=4,o=5,b=180:16a5,16a6"
      - http_request.post:
          url: ${wims_url}/api/scan
          capture_response: true
          # max_response_buffer_size: 200B
          request_headers:
            Content-Type: application/json
          json:
            reader_id: ${reader_id}
            tag_id: !lambda 'return x;'
          on_response:
            - if:
                condition:
                  lambda: return response->status_code == 200;
                then:
                  - display.page.show: page_tag
                  - lambda: |-
                      json::parse_json(body, [](JsonObject root) -> bool {
                          if (root["item_name"]) {
                            id(scanned_item_name) = root["item_name"].as<std::string>();
                          }
                          if (root["item_storage_location"]) {
                            id(scanned_item_location) = root["item_storage_location"].as<std::string>();
                          }
                          return true;
                      });
            - if:
                condition:
                  lambda: return response->status_code == 404;
                then:
                  - display.page.show: page_new
            - if:
                condition:
                  lambda: return response->status_code != 200 && response->status_code != 404;
                then:
                  - display.page.show: page_info
                  - lambda: |-
                      id(rfid_message) = "Backend error";
                  - logger.log:
                      format: "Error: Response status: %d, message %s"
                      args: ["response->status_code", "body.c_str()"]

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    # rotation: 180
    flip_x: true
    id: oled_display
    update_interval: 1s
    pages:
      - id: page_info
        lambda: |-
          it.print(64, 24, id(rfid_font), TextAlign::CENTER, id(rfid_message).c_str());
      - id: page_tag
        lambda: |-
          it.printf(64, 0, id(rfid_font), TextAlign::TOP_CENTER, "%s", id(scanned_item_name).c_str());
          it.printf(64, 20, id(rfid_font), TextAlign::TOP_CENTER, "Lagerort:");
          it.printf(64, 40, id(rfid_font), TextAlign::TOP_CENTER, "%s", id(scanned_item_location).c_str());
          ESP_LOGD("RFID", "Scanned Item Value: %s", id(scanned_item_name).c_str());
      - id: page_new
        lambda: |-
          it.printf(64, 0, id(rfid_font), TextAlign::TOP_CENTER, "New Item!");
          it.printf(64, 40, id(rfid_font), TextAlign::TOP_CENTER, "Check Browser");
          ESP_LOGD("RFID", "Scanned new item Value: %s", id(scanned_item_name).c_str());
      - id: page_qrcode
        lambda: |-
          auto size = id(inventory_manager_url_qr).get_size() * 2;
          auto x = (it.get_width() / 2) - (size / 2);
          auto y = (it.get_height() / 2) - (size / 2);
          it.qr_code(x, y, id(inventory_manager_url_qr), Color(255,255,255), 2);

font:
  - file: "arial.ttf"
    id: rfid_font
    size: 16

output:
  - platform: ledc
    pin: GPIO10
    id: rtttl_out

rtttl:
  output: rtttl_out
